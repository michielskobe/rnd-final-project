----------------------------------------------------------------
-- Company: KUL - rnd embed - Beats N Bytes
-- Engineer: Wout Lyen
-- Project Name: Blendinator
----------------------------------------------------------------
-- -------------------------------------------------------------
-- 
-- File Name: echo_tdm.vhd
-- Created: 2024-11-21 00:32:27
-- 
-- Partially generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
-- 
-- -------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.fixed_pkg.all;
use ieee.math_real.all;

use work.axi4_audio_pkg.all;


entity echo_tdm is
  generic (
        g_coefficient_width : integer := 24;
        g_delay : integer := 20000;  --Minimum 5
        g_chip_scope : string := "False"
    );
  port( 
    -- clocking
    clk : in std_logic;

    -- axi inputs
    axi_in_fwd : in t_axi4_audio_fwd;
    axi_in_bwd : out t_axi4_audio_bwd;

    -- axi outputs
    axi_out_fwd : out t_axi4_audio_fwd;
    axi_out_bwd : in t_axi4_audio_bwd

  );
end echo_tdm;


architecture rtl of echo_tdm is

  -------------------------------------
  -- Memory init
  -------------------------------------
  type t_coefficient_array is array (0 to 2**c_ID_width) of sfixed(g_coefficient_width -1 downto 0);
  signal coefficient_array : t_coefficient_array := (others => to_sfixed(0.5, 0, -23));

  constant bram_size : natural := g_delay*2**c_ID_width;
  type t_data_array is array (0 to bram_size -1) of std_logic_vector(c_audio_width -1 downto 0);
  signal data_array : t_data_array;-- := (others => (others => '0'));
  attribute ram_style : string;
  attribute ram_style of data_array: signal is "block";

  type t_counter_array is array (0 to 2**c_ID_width) of unsigned(integer(ceil(log2(real(g_delay) - real(1)))) downto 0);
  signal counter_array : t_counter_array := (others => (others => '0'));


  -------------------------------------
  -- Data Input
  -------------------------------------
  signal TData_stage_1                    : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  signal TID_stage_1                      : std_logic_vector(c_ID_width -1 downto 0) := (others => '0');

  -------------------------------------
  -- Fetch Coefficients & Counter
  -------------------------------------
  signal TData_stage_2                    : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  signal TID_stage_2                      : std_logic_vector(c_ID_width -1 downto 0) := (others => '0');

  signal TID_counter                      : unsigned(integer(ceil(log2(real(g_delay) - real(1)))) downto 0) := (others => '0');  -- sfix24_En23
  signal TID_gain                         : sfixed(g_coefficient_width -1 downto 0) := (others => '0');
  
  -------------------------------------
  -- Fetch Prev Data
  -------------------------------------
  signal TData_stage_3                    : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  signal TID_stage_3                      : std_logic_vector(c_ID_width -1 downto 0) := (others => '0');

  signal TID_counter_2                    : unsigned(integer(ceil(log2(real(g_delay) - real(1)))) downto 0) := (others => '0');  -- sfix24_En23
  signal TID_gain_2                       : sfixed(g_coefficient_width -1 downto 0) := (others => '0');
  
  signal TID_Prev_Data                    : signed(23 downto 0) := (others => '0');  -- sfix24_En23

  -------------------------------------
  -- Filter
  -------------------------------------
  signal TData_stage_4                    : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  signal TData_stage_5                    : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  signal TID_stage_4                      : std_logic_vector(c_ID_width -1 downto 0) := (others => '0');

  signal TID_counter_3                    : unsigned(integer(ceil(log2(real(g_delay) - real(1)))) downto 0) := (others => '0');  -- sfix24_En23
  
  signal TID_Prev_Data_2                  : signed(23 downto 0) := (others => '0');  -- sfix24_En23

  -- Coefficients
  signal gain_signed                      : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  
  SIGNAL Product_out1                     : signed(47 DOWNTO 0);  -- sfix48_En46
  SIGNAL Sum1_add_cast                    : signed(63 DOWNTO 0);  -- sfix64_En46
  SIGNAL Sum1_add_cast_1                  : signed(63 DOWNTO 0);  -- sfix64_En46
  SIGNAL Echo_1                           : signed(63 DOWNTO 0);  -- sfix64_En46
  SIGNAL Data_Type_Conversion_out1        : signed(23 DOWNTO 0);  -- sfix24_En23
  


  -------------------------------------
  -- Control flow
  -------------------------------------
  signal pipe_startup : integer range 0 to 5 := 5;

   
BEGIN

  -------------------------------------
  -- Data Input
  -------------------------------------
  data_input_process : process (clk)
  begin
    if rising_edge(clk) then
      if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' then
        TData_stage_1 <= signed(axi_in_fwd.TData);
        TID_stage_1 <= axi_in_fwd.TID;
      end if;
    end if;
  end process data_input_process;


  -------------------------------------
  -- Fetch Gain and Counter
  -------------------------------------
  fetch_process : process (clk)
  begin
    if rising_edge(clk) then
      if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' then

        TData_stage_2 <= TData_stage_1;
        TID_stage_2 <= TID_stage_1;

        --Fetch gain from mem
        TID_gain <= coefficient_array(to_integer(unsigned(TID_stage_1)));

        --Fetch counter
        if TID_stage_2 /= TID_stage_1 then
          TID_counter <= counter_array(to_integer(unsigned(TID_stage_1)));
        else
          TID_counter <= (TID_counter+1) mod g_delay;
        end if;

      end if;
    end if;
  end process fetch_process;

  -------------------------------------
  -- Fetch Data and update Counter
  -------------------------------------
  fetch_process_2 : process (clk)
    variable addr : integer := 0;
  begin
    if rising_edge(clk) then
      if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' then

        TData_stage_3 <= TData_stage_2;
        TID_stage_3 <= TID_stage_2;

        TID_gain_2 <= TID_gain;
        TID_counter_2 <= TID_counter;

        --Fetch prev data from mem
        addr := to_integer(unsigned(to_integer(unsigned(TID_stage_2))*g_delay+TID_counter));
        TID_Prev_Data <= signed(data_array(addr));

        --Update counter in mem
        counter_array(to_integer(unsigned(TID_stage_2))) <= (TID_counter+1) mod g_delay;

      end if;
    end if;
  end process fetch_process_2;

  -------------------------------------
  -- Filter
  -------------------------------------
  filter_process : process (clk)
  begin
    if rising_edge(clk) then
      if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' then

        -- Input Data
        TData_stage_4 <= TData_stage_3;
        TID_stage_4 <= TID_stage_3;

        TID_counter_3 <= TID_counter_2;
        TID_Prev_Data_2 <= TID_Prev_Data;

        -- Move Gain to Filter
        gain_signed <= signed(TID_gain_2);

      end if;
    end if;
  end process filter_process;
  
  -- Product
  Product_out1 <= TID_Prev_Data_2 * gain_signed;

  -- Sum
  Sum1_add_cast <= resize(TData_stage_4 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 64);
  Sum1_add_cast_1 <= resize(Product_out1, 64);
  Echo_1 <= Sum1_add_cast + Sum1_add_cast_1;

  -- Output
  Data_Type_Conversion_out1 <= Echo_1(46 DOWNTO 23);
  TData_stage_5 <= Data_Type_Conversion_out1;

  -------------------------------------
  -- Output Data
  -------------------------------------
  data_output_process : process (clk)
    variable addr : integer := 0;
  begin
    if rising_edge(clk) then
      if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' then

        axi_out_fwd.TData <= std_logic_vector(TData_stage_5);
        axi_out_fwd.TID   <= TID_stage_4;

        -- Move Data from Filter
        addr := to_integer(unsigned(to_integer(unsigned(TID_stage_4))*g_delay+TID_counter));
        data_array(addr) <= std_logic_vector(TData_stage_5);

      end if;
    end if;
  end process data_output_process;


  -------------------------------------
  -- Control flow
  -------------------------------------
  -- we are ready if the module behind us is ready
  axi_in_bwd.TReady <= axi_out_bwd.TReady;

  p_ctrl_flow : process (clk)
  begin
      if rising_edge(clk) then
          if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' then

              if pipe_startup = 0 then
                pipe_startup <= pipe_startup;
              else
                pipe_startup <= pipe_startup - 1;
              end if;

          end if;
      end if;
  end process;


  p_valid : process (all)
  begin

      if pipe_startup = 0 then
          axi_out_fwd.TValid <= axi_in_fwd.TValid;
      else
          axi_out_fwd.TValid <= '0';
      end if;

  end process;


END rtl;
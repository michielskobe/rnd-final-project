----------------------------------------------------------------
-- Company: KUL - rnd embed - Beats N Bytes
-- Engineer: Wout Lyen
-- Project Name: Blendinator
----------------------------------------------------------------
-- -------------------------------------------------------------
-- 
-- File Name: ring_modulator.vhd
-- Created: 2024-11-21 00:32:27
-- 
-- Partially generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
-- 
-- -------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use ieee.MATH_REAL.all;
use IEEE.fixed_pkg.all;

use work.axi4_audio_pkg.all;
use work.axi4_mm_filter_pkg.all;


entity ring_modulator is
  generic (
        g_TID_count : integer := 2;
        g_chip_scope : string := "False"
    );
  port( 
    -- clocking
    clk : in std_logic;

    -- axi mm
    axi_in_mm : in t_axi4_mm_ring_mod;

    -- axi inputs
    axi_in_fwd : in t_axi4_audio_fwd;
    axi_in_bwd : out t_axi4_audio_bwd;

    -- axi outputs
    axi_out_fwd : out t_axi4_audio_fwd;
    axi_out_bwd : in t_axi4_audio_bwd

  );
end ring_modulator;


architecture rtl of ring_modulator is

  -------------------------------------
  -- Axi MM
  -------------------------------------
  signal axi_in_mm_1 : t_axi4_mm_ring_mod := axi4_mm_ring_mod_inactive;
  signal axi_in_mm_2 : t_axi4_mm_ring_mod := axi4_mm_ring_mod_inactive;

  -------------------------------------
  -- Ring Modulation Data
  -------------------------------------
  constant PI_POS: signed(15 downto 0) := "0110010011101001";
  constant PI_NEG: signed(15 downto 0) := "1001101100010111";
  
  signal phase_increment: integer := 256;
  signal ring_mod_on_off: std_logic := '0';

  signal Cordic_Phase: signed(15 downto 0) := (others => '0');

  signal Cordic_TData_In: std_logic_vector(15 downto 0);
  signal Cordic_TValid_In: std_logic := '0';
  signal Cordic_TReady_In: std_logic;
  signal Cordic_TData_Out: std_logic_vector(31 downto 0);
  signal Cordic_TValid_Out: std_logic;
  signal Cordic_TReady_Out: std_logic;

  signal Cordic_Cosine: std_logic_vector(15 downto 0);
  signal Cordic_Sine: std_logic_vector(15 downto 0);

  -------------------------------------
  -- FIFO
  -------------------------------------
  signal almost_full : std_logic;
  signal full : std_logic;
  signal din : std_logic_vector(15 downto 0) := (others => '0');
  signal wr_en : std_logic := '0';
  signal wr_data_count: std_logic_vector(integer(ceil(log2(real(32)))) downto 0);
  signal almost_empty : std_logic;
  signal empty : std_logic;
  signal dout : std_logic_vector(15 downto 0) := (others => '0');
  signal rd_en : std_logic := '0';


  -------------------------------------
  -- Data Input
  -------------------------------------
  signal TData_In                         : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  signal TID_In                           : std_logic_vector(c_ID_width -1 downto 0) := (others => '0');
  signal TData_Cosine                     : signed(15 downto 0) := (others => '0');  -- sfix16_En14

  signal TID_counter                      : integer := 0;

  -------------------------------------
  -- Filter
  -------------------------------------
  signal TData_In_2                       : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  signal TData_Cosine_2                   : signed(15 downto 0) := (others => '0');  -- sfix16_En14
  signal TID_In_2                         : std_logic_vector(c_ID_width -1 downto 0) := (others => '0');

  signal TData_In_3                       : signed(23 downto 0) := (others => '0');  -- sfix24_En23
  
  signal Product_out1                     : signed(39 DOWNTO 0);  -- sfix40_En37
  signal Data_Type_Conversion_out1        : signed(23 DOWNTO 0);  -- sfix24_En23

  -------------------------------------
  -- Control flow
  -------------------------------------
  signal pipe_startup : integer range 0 to 3 := 3;

   
BEGIN

  -------------------------------------
  -- Axi MM
  -------------------------------------
  axi_mm : process (clk)
  begin
    if rising_edge(clk) then
      
      axi_in_mm_1 <= axi_in_mm;
      axi_in_mm_2 <= axi_in_mm_1;

      ring_mod_on_off <= axi_in_mm_2.on_off;
      phase_increment <= axi_in_mm_2.phase_inc;

    end if;
  end process;

  -------------------------------------
  -- (Co-)Sine Generating (Cordic)
  -------------------------------------

  Cordic_TData_In <= std_logic_vector(Cordic_Phase);

  cordic_0_inst: entity work.cordic_0
   port map(
      aclk => clk,
      s_axis_phase_tvalid => Cordic_TValid_In,
      s_axis_phase_tready => Cordic_TReady_In,
      s_axis_phase_tdata  => Cordic_TData_In,
      m_axis_dout_tvalid  => Cordic_TValid_Out,
      m_axis_dout_tready  => Cordic_TReady_Out,
      m_axis_dout_tdata   => Cordic_TData_Out
  );

  Cordic_Cosine <= Cordic_TData_Out(15 downto 0);
  Cordic_Sine   <= Cordic_TData_Out(31 downto 16);

  -------------------------------------
  -- Cosine FIFO
  -------------------------------------

  generic_fifo_inst: entity work.generic_fifo
   generic map(
      g_fifo_depth => 32,
      g_fifo_width => 16,
      g_fifo_mode => "fwft"
  )
   port map(
      clk_in => clk,
      clk_out => clk,
      almost_full => almost_full, -- Doesn't work because xpm :(
      full => full,
      din => din,
      wr_en => wr_en,
      wr_data_count => wr_data_count,
      rst => '0',
      --wr_rst_busy => wr_rst_busy,
      almost_empty => almost_empty,
      empty => empty,
      --data_valid => data_valid,
      dout => dout,
      rd_en => rd_en
      --rd_data_count => rd_data_count,
      --rd_rst_busy => rd_rst_busy
  );

  fifo_input_process : process (clk)
  begin
    if rising_edge(clk) then
      wr_en <= '0';

      if Cordic_TValid_Out = '1' and unsigned(wr_data_count) < 31 then
        wr_en <= '1';
        din   <= Cordic_Cosine;
      end if;

    end if;
  end process;

  process (all)
  begin

    Cordic_TReady_Out <= '0';

    if (unsigned(wr_data_count) < 31) then
      Cordic_TReady_Out <= '1';
    end if;
  
  end process;

  -------------------------------------
  -- Phase Generating
  -------------------------------------

  phase_gen_process : process (clk)
  begin
    if rising_edge(clk) then
      
      if Cordic_TReady_In = '1' then
        Cordic_TValid_In <= '1';
        
        if (Cordic_Phase + phase_increment < PI_POS ) then
          Cordic_Phase <= Cordic_Phase + phase_increment;
        else
          Cordic_Phase <= PI_NEG;
        end if;

      end if;
    
    end if;
  end process;

  -------------------------------------
  -- Data Input
  -------------------------------------
  data_input_process : process (clk)
  begin
    if rising_edge(clk) then
      rd_en <= '0';

      if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' and empty = '0' then
        TData_In  <= signed(axi_in_fwd.TData);
        TID_In    <= axi_in_fwd.TID;

        if TID_counter = 0 then
          rd_en         <= '1';
          TData_Cosine  <= signed(dout);
        else
          TData_Cosine <= TData_Cosine;
        end if;

        if TID_counter < g_TID_count - 1 then
          TID_counter <= TID_counter + 1;
        else
          TID_counter <= 0;
        end if;

      end if;
    end if;
  end process data_input_process;


  -------------------------------------
  -- Ring Modulation
  -------------------------------------
  filter_process : process (clk)
  begin
    if rising_edge(clk) then
      if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' and empty = '0' then

        -- Input Data
        TData_In_2      <= TData_In;
        TID_In_2        <= TID_In;

        if ring_mod_on_off = '1' then
          TData_Cosine_2  <= TData_Cosine;  
        else
          TData_Cosine_2  <= to_signed(16#4000#, 16);
        end if;
      end if;
    end if;
  end process filter_process;
  

  -- Product
  Product_out1 <= TData_In_2 * TData_Cosine_2;

  -- Output conversion
  Data_Type_Conversion_out1 <= Product_out1(37 DOWNTO 14);
  TData_In_3 <= Data_Type_Conversion_out1;

  -------------------------------------
  -- Output Data
  -------------------------------------
  data_output_process : process (clk)
  begin
    if rising_edge(clk) then
      if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' and empty = '0' then

        axi_out_fwd.TData <= std_logic_vector(TDATA_In_3);
        axi_out_fwd.TID   <= TID_In_2;

      end if;
    end if;
  end process data_output_process;


  -------------------------------------
  -- Control flow
  -------------------------------------
  -- we are ready if the module behind us is ready
  axi_in_bwd.TReady <= axi_out_bwd.TReady and not empty;

  p_ctrl_flow : process (clk)
  begin
      if rising_edge(clk) then
          if axi_in_fwd.TValid = '1' and axi_out_bwd.TReady = '1' and empty = '0' then

              if pipe_startup = 0 then
                pipe_startup <= pipe_startup;
              else
                pipe_startup <= pipe_startup - 1;
              end if;

          end if;
      end if;
  end process;


  p_valid : process (all)
  begin

      if pipe_startup = 0 then
          axi_out_fwd.TValid <= axi_in_fwd.TValid;
      else
          axi_out_fwd.TValid <= '0';
      end if;

  end process;


END rtl;